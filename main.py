#!/usr/bin/env python3
"""
Script principal para gerenciar o pipeline completo do projeto.
Oferece menu para executar diferentes opera√ß√µes.
"""

import os
import sys
import subprocess
import shutil

def run_script(script_path, description):
    """
    Executa um script Python e exibe o resultado
    """
    print(f"\nüîÑ Executando: {description}")
    print("=" * 50)
    
    try:
        result = subprocess.run([sys.executable, script_path], 
                              capture_output=False, 
                              cwd=os.getcwd())
        
        if result.returncode == 0:
            print(f"\n‚úÖ {description} - Conclu√≠do com sucesso!")
        else:
            print(f"\n‚ùå {description} - Erro na execu√ß√£o!")
            
        return result.returncode == 0
        
    except Exception as e:
        print(f"\n‚ùå Erro ao executar {description}: {str(e)}")
        return False

def run_script_with_args(script_path, args, description):
    """
    Executa um script Python com argumentos e exibe o resultado
    """
    print(f"\nüîÑ Executando: {description}")
    print("=" * 50)
    
    try:
        cmd = [sys.executable, script_path] + args
        result = subprocess.run(cmd, 
                              capture_output=False, 
                              cwd=os.getcwd())
        
        if result.returncode == 0:
            print(f"\n‚úÖ {description} - Conclu√≠do com sucesso!")
        else:
            print(f"\n‚ùå {description} - Erro na execu√ß√£o!")
            
        return result.returncode == 0
        
    except Exception as e:
        print(f"\n‚ùå Erro ao executar {description}: {str(e)}")
        return False

def check_file_exists(file_path, description="arquivo"):
    """
    Verifica se um arquivo existe
    """
    if os.path.exists(file_path):
        print(f"‚úÖ {description}: {file_path}")
        return True
    else:
        print(f"‚ùå {description} n√£o encontrado: {file_path}")
        return False

def ensure_output_directory():
    """
    Garante que a pasta output existe
    """
    if not os.path.exists('output'):
        os.makedirs('output')
        print("üìÅ Pasta 'output' criada")

def copy_to_webapp(source_file, target_file, description="arquivo"):
    """
    Copia arquivo da pasta output para webapp/public/data
    """
    if os.path.exists(source_file):
        # Garantir que o diret√≥rio de destino existe
        target_dir = os.path.dirname(target_file)
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)
        
        shutil.copy2(source_file, target_file)
        print(f"üìã {description} copiado para webapp: {target_file}")
        return True
    else:
        print(f"‚ö†Ô∏è {description} n√£o encontrado para c√≥pia: {source_file}")
        return False

def main():
    """
    Menu principal
    """
    print("üìö INTRODUCTION TO THE DEVOUT LIFE - PIPELINE MANAGER")
    print("=" * 60)
    
    # Verificar estrutura do projeto
    print("\nüìÇ VERIFICANDO ESTRUTURA DO PROJETO:")
    
    # Garantir que a pasta output existe
    ensure_output_directory()
    
    scripts = {
        'epub_process_new': os.path.join('scripts', 'epub_processing', 'epub_to_json_processor.py'),
        'fix_ad_hoc': os.path.join('scripts', 'json_processing', 'fix_ad_hoc.py'),
        'reorganize_json': os.path.join('scripts', 'json_processing', 'reorganize_final.py'),
        'epub_generate': os.path.join('scripts', 'epub_processing', 'gerar_epub_atualizado.py'),
        'ocr_fix': os.path.join('scripts', 'ocr_fixes', 'fix_ocr_manual.py'),
        'split_part_titles': os.path.join('scripts', 'json_processing', 'split_part_titles.py'),
        'docx_clean': os.path.join('scripts', 'translation', 'tradutor_docx_clean.py'),
        'json_reconstruct': os.path.join('scripts', 'translation', 'reconstruir_json_portugues.py')
    }
    
    data_files = {
        'json_en_output': os.path.join('output', 'livro_en.json'),
        'json_pt_output': os.path.join('output', 'livro_pt-BR.json'),
        'json_en_webapp': os.path.join('webapp', 'public', 'data', 'livro_en.json'),
        'json_pt_webapp': os.path.join('webapp', 'public', 'data', 'livro_pt-BR.json'),
        'epub_source': os.path.join('data', 'Introduction_to_the_Devout_Life.epub')
    }
    
    # Verificar scripts
    missing_scripts = []
    for name, path in scripts.items():
        if not check_file_exists(path, f"Script {name}"):
            missing_scripts.append(name)
    
    # Verificar dados
    for name, path in data_files.items():
        check_file_exists(path, f"Dados {name}")
    
    # Verificar arquivo EPUB fonte
    epub_source_exists = check_file_exists(data_files['epub_source'], "EPUB fonte")
    
    if missing_scripts:
        print(f"\n‚ö†Ô∏è  Alguns scripts n√£o foram encontrados: {', '.join(missing_scripts)}")
        print("   Certifique-se de que a estrutura do projeto est√° correta.")
    
    while True:
        print(f"\nüìã MENU PRINCIPAL:")
        print(f"1. üìñ Processar EPUB ‚Üí JSON (com word_count autom√°tico)")
        print(f"2. üîß Aplicar corre√ß√µes ad hoc")
        print(f"3. üìã Reorganizar JSON baseado no summary.csv")
        print(f"4. ü©π Corrigir OCR no JSON ingl√™s")
        print(f"5. ÔøΩ Merge part name to first chapter")
        print(f"6. ÔøΩüìÑ Gerar DOCX para tradu√ß√£o")
        print(f"7. üåê Reconstruir JSON portugu√™s (ap√≥s tradu√ß√£o)")
        print(f"8. üìö Gerar EPUBs atualizados")
        print(f"9. üîÑ Pipeline completo (EPUB ‚Üí Ad hoc ‚Üí Reorganizar ‚Üí OCR ‚Üí Split ‚Üí DOCX ‚Üí Reconstruir ‚Üí EPUBs)")
        print(f"10. ‚ÑπÔ∏è  Mostrar status do projeto")
        print(f"11. üöÄ Iniciar aplica√ß√£o web")
        print(f"12. üìä Comparar contagem de caracteres dos EPUBs")
        print(f"13. üîç Analisar conte√∫do adicionado nas vers√µes geradas")
        print(f"14. ‚ùå Sair")
        
        choice = input(f"\nEscolha uma op√ß√£o (1-14): ").strip()
        
        if choice == '1':
            if not epub_source_exists:
                print("‚ùå Arquivo EPUB fonte n√£o encontrado! Verifique se 'Introduction_to_the_Devout_Life.epub' est√° na pasta 'data'.")
            else:
                # Prioriza o novo processador com word_count autom√°tico
                if 'epub_process_new' not in missing_scripts:
                    success = run_script_with_args(scripts['epub_process_new'], [data_files['epub_source']], 
                                        "Processamento de EPUB (com word_count autom√°tico)")
                    if success:
                        copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s")
                else:
                    print("‚ùå Nenhum script de processamento encontrado!")
                
        elif choice == '2':
            if 'fix_ad_hoc' not in missing_scripts:
                success = run_script(scripts['fix_ad_hoc'], "Corre√ß√µes ad hoc")
                if success:
                    copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s com corre√ß√µes ad hoc")
            else:
                print("‚ùå Script de corre√ß√µes ad hoc n√£o encontrado!")
                
        elif choice == '3':
            if 'reorganize_json' not in missing_scripts:
                success = run_script(scripts['reorganize_json'], "Reorganiza√ß√£o do JSON baseado no summary.csv")
                if success:
                    copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s reorganizado")
            else:
                print("‚ùå Script de reorganiza√ß√£o n√£o encontrado!")
                
        elif choice == '4':
            if 'ocr_fix' not in missing_scripts:
                success = run_script(scripts['ocr_fix'], "Corre√ß√£o de OCR")
                if success:
                    copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s corrigido")
            else:
                print("‚ùå Script de corre√ß√£o de OCR n√£o encontrado!")
                
        elif choice == '5':
            if 'split_part_titles' not in missing_scripts:
                success = run_script(scripts['split_part_titles'], "Split part titles")
                if success:
                    copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s com part titles divididos")
            else:
                print("‚ùå Script de split de t√≠tulos n√£o encontrado!")
                
        elif choice == '6':
            if 'docx_clean' not in missing_scripts:
                run_script(scripts['docx_clean'], "Gera√ß√£o de DOCX para tradu√ß√£o")
            else:
                print("‚ùå Script de gera√ß√£o de DOCX n√£o encontrado!")
                
        elif choice == '6':
            if 'docx_clean' not in missing_scripts:
                run_script(scripts['docx_clean'], "Gera√ß√£o de DOCX para tradu√ß√£o")
            else:
                print("‚ùå Script de gera√ß√£o de DOCX n√£o encontrado!")
                
        elif choice == '7':
            if 'json_reconstruct' not in missing_scripts:
                success = run_script(scripts['json_reconstruct'], "Reconstru√ß√£o de JSON portugu√™s")
                if success:
                    copy_to_webapp(data_files['json_pt_output'], data_files['json_pt_webapp'], "JSON portugu√™s")
            else:
                print("‚ùå Script de reconstru√ß√£o n√£o encontrado!")
                
        elif choice == '8':
            if 'epub_generate' not in missing_scripts:
                run_script_with_args(scripts['epub_generate'], ['--auto'], "Gera√ß√£o de EPUBs")
            else:
                print("‚ùå Script de gera√ß√£o de EPUB n√£o encontrado!")
                
        elif choice == '9':
            if not epub_source_exists:
                print("‚ùå Arquivo EPUB fonte n√£o encontrado! Verifique se 'Introduction_to_the_Devout_Life.epub' est√° na pasta 'data'.")
            else:
                print(f"\nüîÑ EXECUTANDO PIPELINE COMPLETO...")
                success = True
                
                # 1. Processar EPUB
                if 'epub_process_new' not in missing_scripts:
                    success = run_script_with_args(scripts['epub_process_new'], [data_files['epub_source']], 
                                                 "Processamento de EPUB") and success
                    if success:
                        copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s")
                
                # 2. Aplicar corre√ß√µes ad hoc
                if 'fix_ad_hoc' not in missing_scripts and success:
                    success = run_script(scripts['fix_ad_hoc'], "Corre√ß√µes ad hoc") and success
                    if success:
                        copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s com corre√ß√µes ad hoc")
               
                # 3. Reorganizar JSON
                if 'reorganize_json' not in missing_scripts and success:
                    success = run_script(scripts['reorganize_json'], "Reorganiza√ß√£o do JSON") and success
                    if success:
                        copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s reorganizado")
                
                # 4. Corrigir OCR
                if 'ocr_fix' not in missing_scripts and success:
                    success = run_script(scripts['ocr_fix'], "Corre√ß√£o de OCR") and success
                    if success:
                        copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s corrigido")
                
                # 5. Split part titles
                if 'split_part_titles' not in missing_scripts and success:
                    success = run_script(scripts['split_part_titles'], "Split part titles") and success
                    if success:
                        copy_to_webapp(data_files['json_en_output'], data_files['json_en_webapp'], "JSON ingl√™s com part titles divididos")
                
                # 6. Gerar DOCX
                if 'docx_clean' not in missing_scripts and success:
                    success = run_script(scripts['docx_clean'], "Gera√ß√£o de DOCX") and success
                
                # 7. Reconstruir JSON portugu√™s (se existir tradu√ß√£o)
                if 'json_reconstruct' not in missing_scripts and success:
                    # Verificar se existe arquivo de tradu√ß√£o para reconstruir
                    output_dir = 'output'
                    docx_files = []
                    if os.path.exists(output_dir):
                        docx_files = [f for f in os.listdir(output_dir) if f.endswith('.docx') and 'traduzido' in f.lower()]
                    
                    if docx_files:
                        success = run_script(scripts['json_reconstruct'], "Reconstru√ß√£o de JSON portugu√™s") and success
                        if success:
                            copy_to_webapp(data_files['json_pt_output'], data_files['json_pt_webapp'], "JSON portugu√™s")
                    else:
                        print(f"\n‚ö†Ô∏è  Arquivo de tradu√ß√£o n√£o encontrado.")
                        print(f"   Para completar o pipeline, traduza o DOCX gerado e salve com 'traduzido' no nome.")
                
                # 8. Gerar EPUBs (se JSON portugu√™s existir)
                if 'epub_generate' not in missing_scripts and success:
                    if os.path.exists(data_files['json_pt_output']):  # Verificar na pasta output
                        run_script_with_args(scripts['epub_generate'], ['--auto'], "Gera√ß√£o de EPUBs")
                    else:
                        print(f"\n‚ö†Ô∏è  JSON portugu√™s n√£o encontrado.")
                        print(f"   Execute a tradu√ß√£o no Google Translate e depois a reconstru√ß√£o (op√ß√£o 6).")
                
                if success:
                    print(f"\nüéâ PIPELINE CONCLU√çDO!")
                else:
                    print(f"\n‚ùå Pipeline interrompido devido a erros.")
                
        elif choice == '10':
            print(f"\nüìä STATUS DO PROJETO:")
            print("=" * 30)
            
            # Verificar arquivos de dados na pasta output
            en_size_output = os.path.getsize(data_files['json_en_output']) / 1024 if os.path.exists(data_files['json_en_output']) else 0
            pt_size_output = os.path.getsize(data_files['json_pt_output']) / 1024 if os.path.exists(data_files['json_pt_output']) else 0
            
            # Verificar arquivos de dados na webapp
            en_size_webapp = os.path.getsize(data_files['json_en_webapp']) / 1024 if os.path.exists(data_files['json_en_webapp']) else 0
            pt_size_webapp = os.path.getsize(data_files['json_pt_webapp']) / 1024 if os.path.exists(data_files['json_pt_webapp']) else 0
            
            print(f"üìÇ JSON Ingl√™s (output): {'‚úÖ' if en_size_output > 0 else '‚ùå'} ({en_size_output:.1f} KB)")
            print(f"üìÇ JSON Portugu√™s (output): {'‚úÖ' if pt_size_output > 0 else '‚ùå'} ({pt_size_output:.1f} KB)")
            print(f"üìã JSON Ingl√™s (webapp): {'‚úÖ' if en_size_webapp > 0 else '‚ùå'} ({en_size_webapp:.1f} KB)")
            print(f"üìã JSON Portugu√™s (webapp): {'‚úÖ' if pt_size_webapp > 0 else '‚ùå'} ({pt_size_webapp:.1f} KB)")
            
            # Verificar outputs
            output_dir = 'output'
            if os.path.exists(output_dir):
                epubs = [f for f in os.listdir(output_dir) if f.endswith('.epub')]
                print(f"üìö EPUBs gerados: {len(epubs)}")
                for epub in epubs:
                    epub_path = os.path.join(output_dir, epub)
                    epub_size = os.path.getsize(epub_path) / (1024 * 1024)
                    print(f"   üìñ {epub} ({epub_size:.2f} MB)")
            else:
                print(f"üìö EPUBs gerados: 0")
            
            # Verificar DOCX na pasta output
            docx_files = []
            if os.path.exists(output_dir):
                docx_files = [f for f in os.listdir(output_dir) if f.endswith('.docx')]
            print(f"üìÑ Arquivos DOCX: {len(docx_files)}")
            if docx_files:
                for docx in docx_files:
                    docx_path = os.path.join(output_dir, docx)
                    docx_size = os.path.getsize(docx_path) / (1024 * 1024)
                    print(f"   üìÑ {docx} ({docx_size:.2f} MB)")
            
        elif choice == '11':
            webapp_dir = os.path.join('webapp')
            if os.path.exists(webapp_dir):
                print(f"\nüöÄ Iniciando aplica√ß√£o web...")
                try:
                    subprocess.run(['npm', 'start'], cwd=webapp_dir)
                except KeyboardInterrupt:
                    print(f"\nüëã Aplica√ß√£o web encerrada.")
                except Exception as e:
                    print(f"\n‚ùå Erro ao iniciar aplica√ß√£o: {str(e)}")
                    print(f"   Certifique-se de que Node.js est√° instalado e execute 'npm install' na pasta webapp.")
            else:
                print(f"‚ùå Pasta webapp n√£o encontrada!")
                
        elif choice == '12':
            print(f"\nüìä EXECUTANDO COMPARA√á√ÉO DE CARACTERES DOS EPUBs...")
            if os.path.exists('compare_epub_text.py'):
                run_script('compare_epub_text.py', "Compara√ß√£o de contagem de caracteres")
            else:
                print("‚ùå Script compare_epub_text.py n√£o encontrado!")
                
        elif choice == '13':
            print(f"\nüîç EXECUTANDO AN√ÅLISE DE CONTE√öDO ADICIONADO...")
            if os.path.exists('analyze_added_content.py'):
                run_script('analyze_added_content.py', "An√°lise de conte√∫do adicionado")
            else:
                print("‚ùå Script analyze_added_content.py n√£o encontrado!")
                
        elif choice == '14':
            print(f"\nüëã At√© logo!")
            break
            
        else:
            print(f"‚ùå Op√ß√£o inv√°lida! Escolha um n√∫mero de 1 a 14.")

if __name__ == "__main__":
    main()
